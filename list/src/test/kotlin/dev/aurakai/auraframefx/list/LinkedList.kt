/*
 * This source file was generated by the Gradle 'init' task
 */
package dev.aurakai.auraframefx.list

import java.util.LinkedList

class LinkedList : MutableList<String> {
    private var head: Node? = null

    private data class Node(var data: String, var next: Node? = null)

    override val size: Int
        get() = calculateSize()

    private fun calculateSize(): Int {
        var size = 0
        var it = head
        while (it != null) {
            size++
            it = it.next
        }
        return size
    }

    override fun isEmpty(): Boolean = head == null

    override fun contains(element: String): Boolean {
        var it = head
        while (it != null) {
            if (it.data == element) return true
            it = it.next
        }
        return false
    }

    override fun containsAll(elements: Collection<String>): Boolean {
        for (e in elements) {
            if (!contains(e)) return false
        }
        return true
    }

    override fun get(index: Int): String {
        val node = getNodeAt(index) ?: throw IndexOutOfBoundsException("Index: $index")
        return node.data
    }

    private fun getNodeAt(index: Int): Node? {
        if (index < 0) return null
        var it = head
        for (i in 0 until index) {
            it = it?.next ?: return null
        }
        return it
    }

    override fun indexOf(element: String): Int {
        var index = 0
        var it = head
        while (it != null) {
            if (it.data == element) return index
            index++
            it = it.next
        }
        return -1
    }

    override fun lastIndexOf(element: String): Int {
        var lastIndex = -1
        var index = 0
        var it = head
        while (it != null) {
            if (it.data == element) lastIndex = index
            index++
            it = it.next
        }
        return lastIndex
    }

    override fun iterator(): MutableIterator<String> = listIterator()

    override fun listIterator(): MutableListIterator<String> = listIterator(0)

    override fun listIterator(index: Int): MutableListIterator<String> {
        if (index < 0 || index > size) throw IndexOutOfBoundsException("Index: $index, Size: $size")
        
        // Create a snapshot of the current list for iteration
        this.toList()
        
        return object : MutableListIterator<String> {
            private var currentIndex = index
            private var lastReturnedIndex = -1
            private var lastReturned: Node? = if (index > 0) getNodeAt(index - 1) else null

            override fun hasNext() = currentIndex < size

            override fun next(): String {
                if (!hasNext()) throw NoSuchElementException()
                lastReturned = if (currentIndex == 0) head else getNodeAt(currentIndex)
                lastReturnedIndex = currentIndex++
                return lastReturned?.data ?: throw NoSuchElementException()
            }

            override fun nextIndex() = currentIndex

            override fun hasPrevious() = currentIndex > 0

            override fun previous(): String {
                if (!hasPrevious()) throw NoSuchElementException()
                lastReturned = if (currentIndex == 0) null else getNodeAt(currentIndex - 1)
                lastReturnedIndex = --currentIndex
                return lastReturned?.data ?: throw NoSuchElementException()
            }

            override fun previousIndex() = currentIndex - 1

            override fun add(element: String) {
                lastReturned = null
                add(currentIndex, element)
                currentIndex++
                lastReturnedIndex = -1
            }

            override fun remove() {
                check(lastReturnedIndex != -1) { "No element to remove" }
                removeAt(lastReturnedIndex)
                if (lastReturnedIndex < currentIndex) currentIndex--
                lastReturnedIndex = -1
                lastReturned = null
            }

            override fun set(element: String) {
                check(lastReturnedIndex != -1) { "No element to set" }
                set(lastReturnedIndex, element)
            }
        }
    }

    override fun subList(fromIndex: Int, toIndex: Int): MutableList<String> {
        if (fromIndex < 0 || toIndex > size) throw IndexOutOfBoundsException()
        if (fromIndex > toIndex) throw IllegalArgumentException()
        
        val result = LinkedList<String>()
        var current = getNodeAt(fromIndex)
        repeat(toIndex - fromIndex) {
            if (current != null) {
                result.add(current.data)
                current = current.next
            }
        }
        return result
    }

    override fun add(element: String): Boolean {
        val newNode = Node(element)
        val tail = tail(head)
        if (tail == null) {
            head = newNode
        } else {
            tail.next = newNode
        }
        return true
    }

    override fun add(index: Int, element: String) {
        if (index < 0 || index > size) throw IndexOutOfBoundsException("Index: $index, Size: $size")
        val newNode = Node(element)
        if (index == 0) {
            newNode.next = head
            head = newNode
        } else {
            val prev = getNodeAt(index - 1)
            newNode.next = prev?.next
            prev?.next = newNode
        }
    }

    override fun addAll(elements: Collection<String>): Boolean {
        for (e in elements) {
            add(e)
        }
        return elements.isNotEmpty()
    }

    override fun addAll(index: Int, elements: Collection<String>): Boolean {
        if (index < 0 || index > size) throw IndexOutOfBoundsException("Index: $index, Size: $size")
        var currentIndex = index
        for (e in elements) {
            add(currentIndex, e)
            currentIndex++
        }
        return elements.isNotEmpty()
    }

    override fun clear() {
        head = null
    }

    override fun remove(element: String): Boolean {
        var previous: Node? = null
        var it = head
        while (it != null) {
            if (it.data == element) {
                if (previous == null) {
                    head = it.next
                } else {
                    previous.next = it.next
                }
                return true
            }
            previous = it
            it = it.next
        }
        return false
    }

    override fun removeAt(index: Int): String {
        if (index < 0 || index >= size) throw IndexOutOfBoundsException("Index: $index, Size: $size")
        if (index == 0) {
            val data = head?.data ?: throw IndexOutOfBoundsException()
            head = head?.next
            return data
        } else {
            val prev = getNodeAt(index - 1) ?: throw IndexOutOfBoundsException()
            val node = prev.next ?: throw IndexOutOfBoundsException()
            prev.next = node.next
            return node.data
        }
    }

    override fun removeAll(elements: Collection<String>): Boolean {
        var changed = false
        for (e in elements) {
            if (remove(e)) changed = true
        }
        return changed
    }

    override fun retainAll(elements: Collection<String>): Boolean {
        var changed = false
        val toRemove = mutableListOf<String>()
        for (e in this) {
            if (e !in elements) toRemove.add(e)
        }
        for (e in toRemove) {
            remove(e)
            changed = true
        }
        return changed
    }

    override fun set(index: Int, element: String): String {
        val node = getNodeAt(index) ?: throw IndexOutOfBoundsException("Index: $index")
        val old = node.data
        node.data = element
        return old
    }

    private fun tail(head: Node?): Node? {
        var it = head
        while (it?.next != null) {
            it = it.next
        }
        return it
    }
}
